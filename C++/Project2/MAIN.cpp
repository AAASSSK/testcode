#define HUNGRY 1



int Factorial(int num)
{
	if (num == 1)
	{
		return 1;
	}
	return Factorial(num - 1) * num;
}
int main()
{
	//정수형 char(1) short(2) int(4) long(4) long long(8)
	//실수형 float(4) double(8)

	//byte는 8bit 
	// 2의10승 byte는 1kb
	// 2의 10승 1kb는 1mb
	// 2의 10승 1mb는 1gb
	// 2의 10승 1gb는 1tb

	unsigned char c = 0;
	//0~255까지 선언가능
	c = 255;
	signed char c1 = 0;
	//기본적으로 생략 음수양수 다가능.
	//MSB 비트에서 제일 앞자리수 0일때 0~127 1일때 0-128까지 입력
	//이진수도 그냥 더하면 됌 음수 이진수 구하는법 양수 이진수랑 더해서 0되는수로 구하면 된다.
	//부동소수법 실수는 최대한 근사하는것 float 보다 double이 정확할수밖에 없음
	//실수 정수 연산할때 명확하게 표시
	//산술연산자
	//+-*/% %는 피연산자에 실수끼면 계산안됌
	//나누기도 int으로 저장하면 실수 소실 위험 의도한거라면 명확하게 int로 감싸주기 

	//증감 연산자++ --
	//가장느리게 연산된다(후위) 대입연산자보다 느림
	//논리 연산자
	// &&(엔드) ||(or) true false
	//true 0을 제외한 모든수 대표적 1
	//false 0을 의미

	int isTrue;
	isTrue = 0 && 200;  //참 거짓 엔드  거짓

	isTrue = 0 || 200; //참 거짓 or 참

	
	int iTest = 20;
	iTest == 20 ? iTest = 100 : iTest = 200;
	//3항연산자 맞으면 첫번째 실행 틀리면 뒤실행


	//비트 연산자
	//매우 중요합니다.
	//비트 쉬프트 <<2의n배수 된다     >>2^n으로 나눈 몫이 값이 된다(나머지는 소실됌)
	//비트 8개중에서 차례대로 옆으로 움직이면 2를 곱한것과 다름이 없기에
	//비트 곱(&),합(|),xor(^),반전(~)
	//비트 곱 비트끼리 둘중 하나만 0이여도 0으로 바뀜 
	//비트 합은 둘중 하나만 1이여도 1로 바뀜
	//비트 반전 1은 0 0은 1로 반전
	//xor 비트끼리 같으면 0 다르면 1로 비트바뀜
	//전처리기-#붙어서 코드읽기전에 제일먼저실행 define 치환코드 
	//방법 전처리기 읽고 코드 훍어서 그문장 치환시키고 컴파일 들어감.---프로그래머의 편의성 증진 자기 언어로 써도 숫자로 알아서 인식---유지보수 측면에서도 유리

	//스테이터스 표현 방법
	//int 형자료 32비트 존재  unsigned비트로 표현하여 32비트의 공간의 각각의 상태를 1 0으로 표현가능32가지)  
	//defined 이용하여 각각 예시를 들어 배고픔 1로 슬픔 2로 졸림 4 아픔8을 매칭시켜서 비트에서 각각 첫번째 두번째 3번째 자리를 차지할수 있도록한다
	//할당은 비트 합을 이용하여 한다 , 만약 궁금하면 비트 곱을 이용하여 자료이름&배고픔을 시키면 결국 자료형이 0이 아닌수가 되기 때문에 true가 된다
	//비트 빼기 자료이름&~배고픔 시키면 배고픔 수치 빼기 가능.

	//0x 16진수 표현 0x1  0x2 0x4 0x8   0x10 0x20 0x40 0x80   0x100  0x200 0x400 0x800 으로도 표현가능함 각각의 비트define 정의 할때
	//지정한 구문 주석 ctrl +k,c
	//지정한 구문 해제 ctrl +k,u
	//undo ctrl +z
	//ALT DRAG
	//디버깅 단축키F5  중단점 생성 및 해제F9
	//디버깅 중 , 구문 수행(한 프로시져 단위) F10 더 세부적인 구문수행(한 단계씩 실행)  F11
	//디버깅 끄고싶을때 shift+F5  디버깅 건너 뛰고 싶을때 중단점 잡고 한번더 F5
	//큐 선입 선출 후입 후출
	//stack 선입 후출----함수 실행 과정과 매우 비슷하다.

	//재귀함수 잘못쓰면 stackoverflow



	


	return 0;
}